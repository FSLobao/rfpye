# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/.ipynb_checkpoints/07_levels-checkpoint.ipynb (unless otherwise specified).

__all__ = ['extract_level', 'export_level']

# Internal Cell
import os
from pathlib import Path
from typing import *
from collections import defaultdict, namedtuple
from fastcore.basics import partialler, listify
from fastcore.utils import parallel
from fastcore.foundation import L
from .constants import BYTES_HEADER, ENDMARKER, KEY_ATTRS
from .blocks import MAIN_BLOCKS
from .utils import get_files, getattrs, bin2int, bin2str
from .cyparser import cy_extract_compressed
from loguru import logger
import pandas as pd
import numpy as np

# Internal Cell
def _extract_uncompressed(
    blocks: Iterable, rows: int, cols: int, min_level: float, dtype=np.float16
):
    levels = np.full((rows, cols), min_level, dtype=dtype)
    block_data = "raw_data" if dtype == np.uint8 else "levels"
    for b, block in enumerate(blocks):
        levels[b] = getattr(block, block_data)
    return levels

# Cell
def extract_level(spectrum_blocks: L, dtype=np.float32) -> pd.DataFrame:
    """Receives a mapping `spectrum_blocks` and returns the Matrix with the Levels as values, Frequencies as columns and Block Number as index.
    :param pivoted: If False, optionally returns an unpivoted version of the Matrix
    """
    assert len(spectrum_blocks), "The spectrum block list is empty"
    #     spectrum_blocks = spectrum_blocks.itemgot(1)
    block = spectrum_blocks[0]
    assert block.type in (
        63,
        64,
        67,
        68,
    ), "The input blocks are not spectral blocks"

    rows = len(spectrum_blocks)
    cols = min(len(block.data[block.start : block.stop]), block.ndata)
    min_level = 0 if dtype == np.uint8 else block.offset - 127.5
    if block.type in (63, 67):
        #         frequencies = getattr(block, "frequencies")
        return _extract_uncompressed(spectrum_blocks, rows, cols, min_level, dtype)
    thresh = block.thresh - 1
    block_data = [b.raw_data for b in spectrum_blocks]
    #         frequencies = np.linspace(block.start_mega, block.stop_mega, num=cols)
    levels = cy_extract_compressed(block_data, rows, cols, thresh, min_level)
    if dtype != np.float32:
        levels = levels.astype(dtype)
    return levels

# Internal Cell
def _export_level(
    parsed_blocks: tuple,
    stem: Union[str, Path],
    saida: Union[str, Path],
    ext: str = ".fth",
    dtype: Union[str, np.dtype] = np.float16,
) -> None:

    ((tipo, tid), blocos), index = parsed_blocks
    assert (
        tipo in SPECTRAL_BLOCKS
    ), "Tentativa de extrair espectro de um bloco que não é espectral"

    saida = Path(saida)
    level = extract_level(blocos, dtype)
    if index is not None:
        level.index = index

    name = f"{stem}-B_{tipo}_TId_{tid}"
    if ext == ".fth":
        if index is not None:
            level = level.reset_index()
        level.columns = [str(c) for c in level.columns]
        level.to_feather(f"{saida}/{name}{ext}")
    else:
        raise ValueError(f"Extension {ext} not implemented")

# Cell
def export_level(
    stem: Union[str, Path],
    blocks: dict,
    saida: Union[str, Path],
    ext: str = ".fth",
    index: pd.DatetimeIndex = None,
    dtype: Union[str, np.dtype] = np.float16,
) -> None:

    blocks = [((t, i), b) for (t, i), b in blocks.items() if t in SPECTRAL_BLOCKS]
    if not index:
        index = [None] * len(blocks)
    items = list(zip(blocks, index))
    func = partialler(_export_level, stem=stem, saida=saida, ext=ext, dtype=dtype)
    func.__module__ = _export_level.__module__
    parallel(func, items, n_workers=os.cpu_count())