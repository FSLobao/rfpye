# AUTOGENERATED! DO NOT EDIT! File to edit: 03_blocks.ipynb (unless otherwise specified).

__all__ = ['path_type', 'bin_val', 'bytes_encoded', 'datetime_object', 'create_base_block', 'public_attrs', 'getattrs',
           'BaseBlock', 'TimedBlock', 'DType21', 'DType24', 'DType40', 'DType41', 'DType63', 'DType65',
           'block_constructor', 'TYPE_CLASS']

# Cell
import binascii
from datetime import datetime
from collections import namedtuple
from typing import Union, Any, Optional, List, Tuple, Iterator, Mapping, Set, NamedTuple
from .utils import *
from .constants import *
import numpy as np
from fastcore.foundation import GetAttr, L
path_type = Union[str, Any]
bin_val = Union[int, bytes]
bytes_encoded = Union[int, bytes]
datetime_object = datetime

# Cell
BaseBlock = namedtuple('BaseBlock', ' '.join(BASEBLOCK))

def create_base_block(bin_block: bytes)->Tuple:
    """
    Um bloco é um pedaço do arquivo .bin com inicio e final conhecidos e que contém diferentes tipos de informação.
    Possui varios campos: tipo, cabeçalho, dados e rodape.
    Cada campo possui comprimentos e informações definidas na documentação.
    Recebe um bloco do arquivo bin e retorna uma instância de Base Block com os atributos
    'thread_id', 'block_size', 'block_type', 'block_trailer', 'block_data'
    """
    if not isinstance(bin_block, bytes):
        raise TypeError(f"Expected type 'bytes', got '{type(bin_block)}' instead.")
    return BaseBlock(*L(bin_block[:4], bin_block[4:8], bin_block[8:12]).map(bin2dec), bin_block[12:-4])

def public_attrs(obj: Any)->L:
    """Receives an object and return its public attributes (not starting with underscore _) excluding those listed in `EXCLUDE_ATTRS`"""
    return L(k for k in dir(obj) if not k.startswith('_') and k not in EXCLUDE_ATTRS)

def getattrs(obj: Any)->L:
    return {x:getattr(obj, x) for x in public_attrs(obj)}

# Cell
class TimedBlock(GetAttr):
    """
    Aplicável aos tipos de bloco:
        - DataType65
        - DataType63

    Implementa o mapeamento de funções dos blocos que possuem os seguintes campos
    (na mesma posição do vetor binario):F0 a F8

    F0 = (4 bytes) WALLDATE = Wall Clock Start Date of measurements
    F1 = (4 bytes) WALLTIME = Wall Clock Start Time
    F2 = (4u bytes) WALLNANO = Wall Clock Start Time Nanoseconds
    F3 = (2u bytes) STARTMEGA = Start Frequency MHz
    F4 = (4 bytes) STARTMILLI = Start Frequency mHz
    F5 = (2u bytes) STOPMEGA = Stop Frequency MHz
    F6 = (4 bytes) STOPMILLI = Stop Frequency mHz
    F7 = (2u bytes) STARTCHAN = Start Channel number
    F8 = (2u bytes) STOPCHAN = Stop Channel number

    """
    #The attributes which don't belong to this class are delegated to default: i.e Block
    def __init__(self, block: NamedTuple):
        self.default = block

    @property
    def date(self): return bin2date(self.data[BYTES_TIMED[0]]) #F0
    @property
    def time(self): return bin2time(self.data[BYTES_TIMED[1]]) #F1
    @property
    def nanosecs(self): return bin2dec(self.data[BYTES_TIMED[2]], False) #F2
    @property
    def start_mega(self): return bin2dec(self.data[BYTES_TIMED[3]], False) #F3
    @property
    def stop_mega(self): return bin2dec(self.data[BYTES_TIMED[5]], False) #F5
    @property
    def start_mili(self): return bin2dec(self.data[BYTES_TIMED[4]])
    @property
    def stop_mili(self): return bin2dec(self.data[BYTES_TIMED[6]])
    @property
    def start_channel(self): return bin2dec(self.data[BYTES_TIMED[7]], False)
    @property
    def stop_channel(self): return bin2dec(self.data[BYTES_TIMED[8]], False)
    @property
    def datetime_stamp(self):
        return  datetime(2000+self.date[2], self.date[1], self.date[0],
                            self.time[0], self.time[1], self.time[2], int(self.nanosecs/1000))


# Cell
class DType21(GetAttr):
    """Data Type 21 – Unit and Job Information"""
    #The attributes which don't belong to this class are delegated to default: i.e Block
    def __init__(self, block: NamedTuple):
        self.default = block

    @property
    def hostname(self) -> str:
        """Retorna o campo HOSTNAME que contém o 'Unit Hostname'"""
        return bin2str(self.data[BYTES_21[0]])

    @property
    def _get_text1_len(self) -> int:
        """Retorna o tamanho do campo TEXT1 que contém o ‘unit_info’ no arquivo cfg."""
        return bin2dec(self.data[BYTES_21[1]])

    @property
    def unit_info(self) -> str:
        """Retorna o campo TEXT1 que contém o ‘unit_info’ no arquivo cfg."""
        fim = BYTES_21[1].stop + self._get_text1_len
        return bin2str(self.data[16:fim])

    @property
    def _get_text2_len(self) -> int:
        """Retorna o tamanho do campo TEXT2 que contém o ‘unit_info’ no arquivo cfg."""
        inicio = BYTES_21[1].stop + self._get_text1_len
        final = 4 + inicio
        return bin2dec(self.data[inicio:final])

    @property
    def method(self) -> str:
        """Retorna o campo TEXT2 que contém o ‘method’ no arquivo cfg."""
        inicio = BYTES_21[1].stop + self._get_text1_len + 4
        fim = inicio + self._get_text2_len
        return bin2str(self.data[inicio:fim])

# Cell
class DType24(GetAttr):
    """Data Type 24 – Data Thread Information"""
     #The attributes which don't belong to this class are delegated to default: i.e Block
    def __init__(self, block: NamedTuple):
        self.default = block

    @property
    def group_id(self) -> int:
        """F0 - Número identificador do grupo. Zero significa que não faz parte de nenhum grupo"""
        return bin2dec(self.data[:4])

    @property
    def len_text(self) -> int:
        """F1 - Comprimento do texto incluindo bytes nulos ao final (número inteiro de 4 bytes)."""
        return bin2dec(self.data[4:8])

    @property
    def text(self) -> str:
        """F2 - Texto armazenado no bloco sem os bytes nulos ao final"""
        return bin2str(self.data[8:])

# Cell
class DType40(GetAttr):
    """Data Type 40 – GPS Data"""

    def __init__(self, block: NamedTuple):
        """This implementation substitues inheritance of the class Block by Composition
        The attributes which belong to Block are accessed normally as if it was Inherited
        """
        self.default = block

    @property
    def date(self) -> Tuple:
        """F0 = (4 bytes) WALLDATE = Wall Clock Start Date of measurements"""
        return bin2date(self.data[:4])

    @property
    def time(self) -> Tuple:
        """F1 = (4 bytes) WALLTIME = Wall Clock Start Time"""
        return bin2time(self.data[4:8])

    @property
    def nanosecs(self) -> Tuple:
        """F2 = (4u bytes) WALLNANO = Wall Clock Start Time Nanoseconds"""
        return bin2dec(self.data[8:12], False)

    @property
    def wallclock_date_time_stamp(self) -> Tuple:
        """Returns tuple with attributes `date`, `time` and `nanosecs`"""
        return self.date, self.time, self.nanosecs

    @property
    def gps_date(self) -> Tuple[int, int, int, int]:
        """F3 = (4 bytes) WALLDATE = Wall Clock Start Date of measurements"""
        return bin2date(self.data[12:16])

    @property
    def gps_time(self) -> Tuple[int, int, int, int]:
        """F4 - GPS Date. Date from GPS reading (dd/mm/yy/null)"""
        return bin2time(self.data[16:20])

    @property
    def gps_date_time_stamp(self)-> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int], int]:
        """Returns a tuple with `gps_time` and `gps_time`"""
        return self.gps_date, self.gps_time

    @property
    def gps_status(self) -> Union[str, int]:
        """Positional Fix and status.
        If status=1: 0=No Fix, 1=Standard GPS, 2=Differential GPS. If status=0: set to zero.
        """
        status_dict = {0:'No Fix', 1:'Standard GPS', 2:'Differential GPS'}
        status = bin2dec(self.data[20:21])
        return status_dict.get(status, status)

    @property
    def num_sattelites(self) -> int:
        """Satellites in view. 0=bad, 1+ better"""
        return bin2dec(self.data[21:22])

    @property
    def heading(self) -> float:
        """Heading. Degrees * 100 """
        return bin2dec(self.data[22:24])/100

    @property
    def latitude(self) -> float:
        """Latitude = Degrees * 1000000: +ve=N, -ve=S"""
        return bin2dec(self.data[24:28]) / 1000000

    @property
    def longitude(self) -> float:
        """F9 - (4 bytes) Longitude = Degrees * 1000000: +ve=E, -ve=W"""
        return bin2dec(self.data[28:32]) / 1000000

    @property
    def speed(self) -> float:
        """F10 - (4 bytes) Speed = kph * 1000"""
        return bin2dec(self.data[32:36]) / 1000

    @property
    def altitude(self) -> float:
        """F11 = (4 bytes) Altitude = Metres * 1000"""
        return bin2dec(self.data[36:40]) / 1000

# Cell
class DType41(GetAttr):
    """Data Type 41 – Timed Free Text Information"""
    def __init__(self, block: NamedTuple):
        """This implementation substitues inheritance of the class Block by Composition
        The attributes which belong to Block are accessed normally as if it was Inherited
        """
        self.default = block

    @property
    def date(self) -> Tuple[int, int, int, int]:
        """F0 = (4 bytes) Date from Wall Clock (dd/mm/yy/null)"""
        return bin2date(self.data[:4])

    def time(self) -> Tuple[int, int, int, int]:
        """F1 = (4 bytes) Time from Wall Clock (hh/mm/ss/cc)"""
        return bin2time(self.data[4:8])

    def nanosecs(self) -> int:
        """F2 = (4 bytes - 32 bit unsigned integer) Wall Clock Start Time Nanoseconds.
                Must be 0 if cc>0.
        """
        return bin2dec(self.data[8:12], False),

    @property
    def wallclock_date_time_stamp(self) -> Tuple:
        """Returns tuple with attributes `date`, `time` and `nanosecs`"""
        return self.date, self.time, self.nanosecs


    @property
    def identifier(self) -> str:
        """F3 = (32 bytes) Fixed Length Data Type Identifier, null terminated string
        Tells the software how to deal with the free text.
        Defined types:
        - LOGGER_NAME: Application name
        - LOGGER_VERSION: Application version
        - AUDIT: Audit process output
        - GPRS: GPRS message
        - GSM: Cell survey information
        - INFO: Voltages, currents and temperatures
        - LED: LED status
        - MASK: Mask status
        - MESSAGE: Message text
        - NMEA: GSM NMEA text
        - SNMP: SNMP Message text
        - CONF: NCPD Configuration
        """
        return bin2str(self.data[12:44])

    @property
    def len_text(self) -> int:
        """F4 - (4 bytes) NTEXT = Free Text Length. Including null termination and padding
                (must be a whole number of 4 bytes)
        """
        return bin2dec(self.data[44:48])

    @property
    def text(self) -> str:
        """F5 = (NTEXT bytes) Null terminated Free Text"""
        return bin2str(self.data[48:])

# Cell
class DType63(GetAttr):
    """Data Type 63 – Spectral Data - Frequencies and its levels

    The Following attributes are delegated to the `self.default` object

    F0 = (4 bytes) WALLDATE = Wall Clock Start Date of measurements
    F1 = (4 bytes) WALLTIME = Wall Clock Start Time
    F2 = (4u bytes) WALLNANO = Wall Clock Start Time Nanoseconds
    F3 = (2u bytes) STARTMEGA = Start Frequency MHz
    F4 = (4 bytes) STARTMILLI = Start Frequency mHz
    F5 = (2u bytes) STOPMEGA = Stop Frequency MHz
    F6 = (4 bytes) STOPMILLI = Stop Frequency mHz
    F7 = (2u bytes) STARTCHAN = Start Channel number
    F8 = (2u bytes) STOPCHAN = Stop Channel number
    Total Bytes = 52 + (4 * NTUN) + NAGC + NDATA + NPAD
    """
    def __init__(self, block: NamedTuple)-> None:
        self.default = TimedBlock(block)


    @property
    def spent_time_microsecs(self) -> int:
        """F9 = (4 bytes) SAMPLE = Duration of sampling.Time taken by the FPGA and Radio to execute command in µs."""
        return bin2dec(self.data[BYTES_63[9]])

    @property
    def num_meas(self) -> int:
        """F10 =(4 bytes) NAMAL = Amalgamated  Results"""
        return bin2dec(self.data[BYTES_63[10]])

    @property
    def id_antenna(self) -> int:
        """F11 = (1u byte) ANTUID Antenna number [ 0- 255]"""
        return bin2dec(self.data[BYTES_63[11]], False)

    @property
    def processing(self) -> Union[str, int]:
        """F12 = (1 byte) PROC = Processing
                    0 = single measurement,
                    1 = average,
                    2 = peak,
                    3 = minimum
        """
        proc = bin2dec(self.data[BYTES_63[12]])
        return DICT_PROCESSING.get(proc, proc)

    @property
    def unit(self) -> Union[str, int]:
        """F13 = (1 byte) DTYPE = Data Type. 0 = dBm, 1 = dBuV/m"""
        unit: int = bin2dec(self.data[BYTES_63[13]])
        return DICT_UNIT.get(unit, unit)

    @property
    def level_offset(self) -> int:
        """F14 = (1 byte) OFFSET = Data level offset in DTYPE units 2’s Complement, range [-128, 127]."""
        return bin2dec(self.data[BYTES_63[14]])

    @property
    def global_error_code(self) -> int:
        """F15 = (1 byte) GERROR = Global Error Code. Radio or processing global error code
"""
        return bin2dec(self.data[BYTES_63[15]])

    @property
    def global_flags_code(self) -> int:
        """F16 - Códigos de alertas globais ou de processamento do radio."""
        return bin2dec(self.data[BYTES_63[16]])

    @property
    def group_id(self) -> int:
        """F17 - O ID do grupo à qual a medida pertence.0 caso não pertença a nenhum grupo."""
        return bin2dec(self.data[42:43])

    @property
    def n_tunning(self) -> int:
        """F18 - 0 ou igual à quantidade de valores de AGC usados na amostra"""
        return bin2dec(self.data[43:45])

    @property
    def n_agc(self) -> int:
        """F19 - 0 ou igual à quantidade de valores de "tunings" usados na amostra"""
        return bin2dec(self.data[45:47])

    @property
    def n_padding(self) -> int:
        """F20 - Valor que varia de 0 a 3 indicando o preenchimento nulo para manter o tamanho do bloco (em bytes) fixo"""
        return bin2dec(self.data[39:40])

    @property
    def data_points(self) -> int:
        """F21 - O número de canais (ou "steps") que dividem igualmente a largura de banda"""
        return bin2dec(self.data[48:52])

    @property
    def bw(self)-> int:
        """Retorna a faixa de frequência do bloco. STOP_MEGA - START_MEGA"""
        return self.stop_mega - self.start_mega

    @property
    def passo(self)-> float:
        """Retorna a faixa divida pelo número de pontos - 1"""
        return self.bw / (self.data_points - 1)

    def frequencies(self) -> np.array:
        """Retorna um numpy array com a faixa de frequências presentes no bloco"""
        return self.start_mega + np.arange(len(self)) * self.passo

    @property
    def rbw(self) -> int:
        """Retorna o RBW calculado a partir de STARTMEGA, STOPMEGA e NDATA."""
        return int(self.passo * 1000000)

    @property
    def tunning_info(self) -> str:
        """F22 - Informações do 'tunning'. One Block per tunning(1 or 10MHz)"""
        start = 52  # inicia aqui
        stop = start + (4 * self.n_tunning)
        #tunning = {f'{bin2dec(self.data[i:i+2])}MHz':TUNING_BLOCK.get(self.data[i+3], 0) for i in range(start, stop, 4)}
        flags = {TUNING_BLOCK.get(self.data[i+3], 0) for i in range(start, stop, 4)}
        if len(flags) == 1:
            return flags.pop()
        return flags

    @property
    def agc_array(self) -> str:
        """F23 - Array com AGC - Automatic Gain Control as dB in single unsigned byte: 0...63"""
        start = 52+(self.n_tunning * 4)
        stop = start+(self.n_agc)
        #return np.fromiter(self.data[start:stop], np.uint8)
        return '-'.join(L(self.data[start:stop]).map(str))

    @property
    def block_data(self) -> np.array:
        """Spectrum Data in 'dB' with 0.5 dBm interval"""
        start = 52+(self.n_tunning * 4) + self.n_agc
        stop = start+(self.data_points)
        return np.fromiter(self.data[start:stop], dtype=np.float16) / 2 + self.level_offset - 127.5

    def __getitem__(self, i):
        """Return a tuple with frequency, spectrum_data"""
        return self.frequencies[i], self.block_data[i]

    def __len__(self):
        return int(self.data_points)

    def __iter__(self):
        return iter(self[i] for i in range(len(self)))

# Cell
class DType65(GetAttr):
    """
    O Bloco do tipo 65 carrega dados de Taxa de Ocupação Espectral por Canal de Frequência (ITU-R SM.1880).

    O tamanho total em bytes é (48 + NDATA + NPAD)

    F0 a F16 e F19 já inicializados na classe TimedBlock.

   *F0 = (4 bytes) WALLDATE = Wall Clock Start Date of measurements
   *F1 = (4 bytes) WALLTIME = Wall Clock Start Time
   *F2 = (4u bytes) WALLNANO = Wall Clock Start Time Nanoseconds
   *F3 = (2u bytes) STARTMEGA = Start Frequency MHz
   *F4 = (4 bytes) STARTMILLI = Start Frequency mHz
   *F5 = (2u bytes) STOPMEGA = Stop Frequency MHz
   *F6 = (4 bytes) STOPMILLI = Stop Frequency mHz
   *F7 = (2u bytes) STARTCHAN = Start Channel number
   *F8 = (2u bytes) STOPCHAN = Stop Channel number
    F9 = (4 bytes) NAMAL = Amalgamated Results
                    i.e. ‘number of loops’. Equal to 1 if single measurement.
    F10 = (1u bytes) ANTUID Antenna number [ 0- 255]
    F11 = (1 byte) PROC = Processing
                    0 = single measurement,
                    1 = average,
                    2 = peak,
                    3 = minimum
    F12 = (2 bytes) DTYPE = Data Type
                    1 = dBm,
                    2 = dBuV/m
    F13 = (1 byte) GERROR = Global Error Code. Radio or processing global error code
    F14 = (1 byte) GFLAGS = Global clipping flags etc. Radio or processing global flags:
    F15 = (1 bytes) GROUPID = ID used to group sets of data
                    0 = not a member of a group
    F16 = (1 byte) NPAD = Number of bytes of padding. 0-3
    F17 = (2 bytes) THRESH = Threshold Level in DTYPE
    F18 = (2 bytes) DURATION = Duration of sampling. In seconds  (i.e. 300, 900, 1800, 2600)
    F19 = (4 bytes) NDATA = Number of single byte data points.
                    Number of equal width channels dividing the reported frequency width
    F20 = (NDATAu bytes) Array of data points.
                    Each data point is stored as a single byte number
                    representing  the percentage (0..100 % in 0.5 steps)
    F21 = (NPAD bytes) Padding. As \0 bytes
    """
    def __init__(self, block: NamedTuple)-> None:
        self.default = TimedBlock(block)

    @property
    def num_meas(self) -> int:
        """
        self > int
        :return: O número de resultados agrupados. Se for 1 equivale a uma única medida.

        Overrides method in TimedBlock.

        F9 = (4 bytes) NAMAL = Amalgamated Results
                    i.e. ‘number of loops’. Equal to 1 if single measurement.
        """
        return bin2dec(self.data[28:32])

    @property
    def antenna(self) -> int:
        """
        self > int
        :return: o ID da antena usada na medida.

        Overrides method in TimedBlock.

        F10 = (1u bytes) ANTUID Antenna number [ 0- 255]
        """
        return bin2dec(self.data[32:33], False)

    @property
    def processing(self) -> Union[str, int]:
        """
        self > (int, str)
        :return: O código e a descrição do tipo de processamento aplicado à medida.

        Overrides method in TimedBlock.

        F11 = (1 byte) PROC = Processing
                    0 = single measurement,
                    1 = average,
                    2 = peak,
                    3 = minimum

        Data Type 65, Field 11
        Data Type 63, Field 12
        """
        proc = bin2dec(self.data[33:34])
        return DICT_PROCESSING.get(proc, proc)

    @property
    def unit(self) -> Union[str, int]:
        """
        self > str or int
        :return: A unidade de medida.
                Retorna um número inteiro se a unidade não foi documentada.

        Overrides method in TimedBlock.

        todo: Não está funcionando, todos os dados retornam o valor 0!

        F12 = (1 byte) DTYPE = Data Type
            0 = % (não documentado)
            1 = dBm
            2 = dBuV/m
        """
        unit = bin2dec(self.data[34:36])
        return DICT_UNIT.get(unit, unit)

    @property
    def global_error_code(self) -> int:
        """
        self > int
        :return: O código de erro global.

        Overrides method in TimedBlock.

        F13 = (1 byte) GERROR = Global Error Code.
                    Radio or processing global error code

        The radio error codes and flags can be provided on request.
        """
        return bin2dec(self.data[36:37])

    @property
    def global_flags_code(self) -> int:
        """
        self > int
        :return: Códigos de alertas globais ou de processamento do radio.

        Overrides method in TimedBlock.

        F14 = (1 byte) GFLAGS = Global clipping flags etc.
                    Radio or processing global flags.

        The radio error codes and flags can be provided on request.
        """
        return bin2dec(self.data[37:38])

    @property
    def group_id(self) -> int:
        """
        self > int
        :return: O ID do grupo à qual a medida pertence.
                 Caso 0 não pertence a nenhum grupo.
                 Use a classe 'DataType24' para detalhes do grupo.

        Overrides method in TimedBlock.

        F15 = (1 bytes) GROUPID = ID used to group sets of data
                    0 = not a member of a group
        """
        return bin2dec(self.data[38:39])

    @property
    def len_padding(self) -> int:
        """
        self > int
        :return: Valor que varia de 0 a 3 indicando o preenchimento nulo para manter o tamanho do bloco (em bytes) fixo.

        Overrides method in TimedBlock.

        A extração do NPAD (quantidade) tem pouca utilidade prática.
        A extração do Padding (valor) não tem utilidade prática.

        F16 = (1 byte) NPAD = Number of bytes of padding. 0-3
        (NPAD bytes) Padding = As \0 bytes
        """
        return bin2dec(self.data[47:48])

    @property
    def threshold(self) -> int:
        """
        self > int
        :return: O valor do limiar de detecção. A unidade é dada por self._get_unit().

        F17 = (2 bytes) THRESH = Threshold Level in DTYPE
        """
        return bin2dec(self.data[40:42])

    @property
    def duration_seconds(self) -> int:
        """
        self > int
        :return: A duração da amostra em segundos.

        F18 = (2 bytes) DURATION = Duration of sampling. In seconds
                    (i.e. 300, 900, 1800, 2600)
        """
        return bin2dec(self.data[42:44])

    @property
    def data_points(self) -> int:
        """
        self > int
        :return: O número de canais (ou "steps") que dividem igualmente a largura de banda .

        Overrides method in TimedBlock.

        F19 = (4 bytes) NDATA = Number of single byte data points.
                        Number of equal width channels dividing the reported frequency width
        """
        return bin2dec(self.data[44:48])

    def block_data(self) -> np.array:
        """
        self > -> List[float]
        :return: A lista de todas as medidas de ocupação do bloco em '%'.

        F20 = (NDATAu bytes) Array of data points.
                    Each data point is stored as a single byte number
                    representing  the percentage (0..100 % in 0.5 steps)
        """
        start = 48
        end = self.data_points
        return np.fromiter(self.data[start:end], dtype=np.float16) / 2

TYPE_CLASS = {
    21: DType21,
    24: DType24,
    40: DType40,
    41: DType41,
    63: DType63,
    65: DType65
}

def block_constructor(btype, bloco):
    constructor = TYPE_CLASS.get(btype)
    if constructor:
        return constructor(bloco)
    return None